//
// ingestion.proto
//
// Contains methods and data types specific to the Ingestion Service.

syntax = "proto3";

package dp.service.ingestionstream;

option java_multiple_files = true;
option java_package = "com.ospreydcs.dp.grpc.v1.ingestionstream";

import "common.proto";


//
// ------------------- RPC Interfaces ---------------------------
//

/*
 * The Ingestion Stream Service Interface
 *
 * Defines RPC operations for processing of the ingestion data stream.
 *
 */
service DpIngestionStreamService {

  /*
    * subscribeDataEvent(): Register a subscription for data events triggered by new data in the ingestion stream.
    *
    * This method allows the client to register a subscription for a data event, and receive notification when new data
    * is received by the Ingestion Service that triggers the specified event.  The method uses server-side streaming,
    * where the client sends a single SubscribeDataEventRequest message and receives a stream of
    * SubscribeDataEventResponse messages in the response stream.
    *
    * To initiate a new subscription, the client sends a SubscribeDataEventRequest message whose payload message
    * specifies the details for the data event to be monitored.
    *
    * The service responds with a single SubscribeDataEventResponse message, containing either an ExceptionalResult
    * message payload if the request is rejected by the service or an AckResult message if the service accepts the
    * request and registers the subscription.
    *
    * The service then sends a stream of SubscribeDataEventResponse messages, each containing a SubscribeDataEventResult
    * payload containing details of a data event triggered by the monitor.
    *
    * There is not an explicit cancel mechanism, so the subscription lives until the client application closes.
    * An explicit cancel mechanism, following the pattern of the Ingestion Service's subscribeData() API method,
    * will be added when we revisit the Ingestion Stream Service and associated plugin application framework in an
    * upcoming release.
    *
    * The service sends a response with an ExceptionalResult payload if it rejects the subscription request or an error
    * occurs while handling the subscription.  In either case, after sending the ExceptionalResult message the service
    * closes the API method response stream.
    */
  rpc subscribeDataEvent(stream SubscribeDataEventRequest) returns (stream SubscribeDataEventResponse);

}


//
// ------------------- Ingestion Stream Data Event Monitoring ---------------------------
//

/*
 * SubscribeDataEventRequest
 *
 * The client sends a single SubscribeDataEventRequest message when invoking the subscribeData() API method.
 * TODO
 */
message SubscribeDataEventRequest {

  oneof request {
    NewSubscription newSubscription = 10;
    CancelSubscription cancelSubscription = 11;
  }

  message NewSubscription {
    repeated PvConditionTrigger triggers = 1;
    DataEventOperation operation = 2;
  }

  message CancelSubscription {
    // empty message sent to cancel subscription
  }
}

/*
 * SubscribeDataEventResponse
 *
 * The service sends SubscribeDataEventResponse messages in the response stream for the subscribeDataEvent() method.
 * Each response contains one of three payload messages.  1) An ExceptionalResult payload is sent if the service
 * rejects the subscription request or an error occurs while processing the subscription. 2) An AckResult payload
 * is sent when the service accepts a subscription request.  3) A SubscribeDataEventResult is sent when new data
 * are received by the Ingestion Service that triggers the data event monitor for the subscription.
 *
 * Each SubscribeDataEventResult message contains a payload determined by the type data event definition specified for
 * the subscription's request.
 *
 * For this prototype implementation, there is a single result payload message ConditionEvent that corresponds
 * to the request data event definition type ConditionEventDef.  A ConditionEvent contains the name of the PV,
 * timestamp, and data value for a data value satisfying the condition event definition specified in the corresponding
 * request.  A separate ConditionEvent message is sent each time the monitor is satisfied during the life
 * of the subscription.
 */
message SubscribeDataEventResponse {

  Timestamp responseTime = 1; // Indicates time response is generated.

  oneof result {
    ExceptionalResult exceptionalResult = 10;
    AckResult ack = 11;
    Event event = 12;
    EventData eventData = 13;
  }

  message AckResult {
    // empty message sent to confirm subscription
  }

  message Event {
    Timestamp eventTime = 1;
    PvConditionTrigger trigger = 2;
    DataValue dataValue = 3;
  }

  message EventData {
    Event event = 1;
    repeated DataBucket dataBuckets = 2;
  }
}

/*
 * PvConditionTrigger
 *
 * TODO
 */
message PvConditionTrigger {

  string pvName = 1;
  PvCondition condition= 2;
  DataValue value = 3;

  enum PvCondition {
    PV_CONDITION_UNSPECIFIED = 0;
    PV_CONDITION_EQUAL_TO = 1;
    PV_CONDITION_GREATER = 2;
    PV_CONDITION_GREATER_EQ = 3;
    PV_CONDITION_LESS = 4;
    PV_CONDITION_LESS_EQ = 5;
  }
}

message DataEventOperation {

  DataEventWindow window = 1;
  repeated string targetPvs = 2;

  // Process operation = 3;  // The idea eventually is to add a field specifying additional processing to perform,
  // beyond just returning data for the specified PVs

  message DataEventWindow {

    oneof type {
      TimeInterval timeInterval = 10;
      //        SampleCount sampleCount = 11;
    }

    message TimeInterval {
      int64 offset = 1;  // offset from trigger time in nanoseconds (negative value means before trigger time)
      uint64 duration = 2; // number of nanoseconds of data to capture from trigger time modified by offset
    }

    // SampleCount is not supported yet since it's not clear how it should work when there are multiple PVs with
    // different timescales.
    //      message SampleCount {
    //        int64 offset = 1; // offset from trigger time in nanoseconds (negative value means before trigger time)
    //        uint32 size = 2; // number of data values to capture from trigger time modified by offset
    //      }
  }
}


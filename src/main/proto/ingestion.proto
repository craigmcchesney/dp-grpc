syntax = "proto3";

option java_package = "com.ospreydcs.dp.grpc.v1.ingestion";

import "common.proto";

/**
 * Return provider ID after registration
 */
message ProviderID {
  uint32 providerID = 1;
  OperationStatus status = 2;
}

/**
 * Return snapshot ID after providing a snapshot
 */
message SnapshotID {
  uint32 snapshotID = 1;
  OperationStatus status = 2;
}

/**
 * Snapshot Data Provider Configuration
 *
 * @param name        the name of the snapshot data provider
 * @param attributes  an optional list of custom attributes.  Custom attributes can be used to specify any
 *                    additional attributes that the SDP writer wants.  These can be used by clients of the
 *                    data service in queries to select data.
 *                    e.g., attribute `project` could be used as follows: ` where SDP.project="scorpius" `
 */
message SnapshotProviderConfig {
  string name = 1;
  repeated Attribute attributes = 2;
}

/**
 * Snapshot data
 * @param snapshotProviderId    Identity of the snapshot provider
 * @param snapshotId            If a time reference has already been sent then this snapshot ID will identify it
 * @param timeReference         The time reference if none has been sent already
 * 2. Send a `DataSet`, or `TimeReference`
 *   - Only one `TimeReference` can be sent per snapshot.
 * 3. Once all snapshot data has been sent, close the stream to retrieve the snapshotID and status
 * 4. If a snapshot ID is provided then the server uses that to look up the time reference from a previous stream for the same snapshot
 */
message SnapshotData {
  uint32 snapshotDataProviderID = 1;
  uint32 snapshotID = 2;
  TimeReference timeReference = 3;
  repeated Data pvData = 4;
  repeated AggregatedData aggregatedDataset = 5;
  repeated Attribute attributes = 6;
}

/**
 * A Time reference is a way of correlating snapshot data with time.
 * A time reference can be iterated over to deliver a timestamp for all data
 * that it relates to.
 *
 * The snapshotTimestamp is the start of the snapshot window and is independent of the time
 * the data in the related dataset actually starts.
 * The snapshotTimestamp usually comes from some synchronisation pulse that
 * triggers an experiment or run. It serves to group all
 * data that is to be considered part of the same snapshot.
 *
 * The time reference can be provided in one of two ways:
 * - iterator: An initial (first) timestamp and a period can be specified, or
 * - list: A fixed list of timestamps (cannot be variable length)
 *
 * For data that is does not have a regular frequency, Timestamp lists must be used.
 */
message TimeReference {
  Timestamp snapshotTimestamp = 1;
  oneof value_oneof {
    TimestampIterator iterator = 2;
    TimestampList list = 3;
  }
}

/**
 * Use if time reference is a single timestamp & period
 * For example, to make time reference 100 samples, starting at time t, sampled at a rate of 1 MHz
 * use:
 *   timestamp = {timestamp for time t}
 *   periodNanos = 1000
 *   n = 100
 */
message TimestampIterator {
  Timestamp timestamp = 1;
  uint64 periodNanos = 2;
}

/**
 * Use if time reference is a timestamp dataset
 * if startIndex is provided then the list will be merged to a prior time reference list
 * replacing everything from startIndex with the new list.
 * So you can supply batches of data with associated timestamps on the fly
 * which still form part of the same snapshot.
 */
message TimestampList {
  uint32 startIndex = 1;
  repeated Timestamp timestamps = 2;
}

///////////////////////////////////////////////////////////
// Service endpoints
// Register Provider: returns coherent provider ID for a given snapshot provider name
// Stream Snapshot Data: returns distinct snapshot IDs for distinct (provider ID/initial timestamp)
// Add Snapshot Data: returns distinct snapshot IDs for distinct (provider ID/initial timestamp)
///////////////////////////////////////////////////////////
service IngestionService {
  rpc registerProvider (SnapshotProviderConfig) returns (ProviderID);
  rpc streamSnapshotData (stream SnapshotData) returns (SnapshotID);
  rpc addSnapshotData (SnapshotData) returns (SnapshotID);
}
